use commands::{Command, CommandExecutor};
use errors::crypto::CryptoError;

use std::sync::Arc;

pub struct CryptoAPI {
    command_executor: Arc<CommandExecutor>,
}

impl CryptoAPI {
    /// Constructs a new `CryptoAPI`.
    ///
    /// #Params
    /// command_executor: Reference to `CommandExecutor` instance.
    ///
    pub fn new(command_executor: Arc<CommandExecutor>) -> CryptoAPI {
        CryptoAPI { command_executor: command_executor }
    }

    /// Generates public/private keys pair for Libsodium/ECC based asymmetric crypto algorithm.
    ///
    /// Note that keys are represented as byte array and can contain 0 symbols and non-utf8 sequences.
    /// To convert this keys from/to string use `base58_encode` and `base58_decode` methods.
    ///
    /// #Params
    /// cb: Callback that takes command result as parameter.
    ///
    /// #Returns
    /// (public_key, private_key) tuple. Each key is represented as byte array.
    ///
    /// #Errors
    /// No method specific errors.
    /// See `CryptoError` docs for common errors description.
    pub fn sodium_create_key_pair(seed: Option<&str>, cb: Box<Fn(Result<(Vec<u8>, Vec<u8>), CryptoError>) + Send>) {
        unimplemented!();
    }

    /// Encrypts document with Libsodium/ECC based asymmetric crypto algorithm.
    ///
    /// #Params
    /// public_key: Libsodium public key as byte array. Can be generated by calling `sodium_create_key_pair`.
    /// doc: Document to encrypt as byte array.
    /// cb: Callback that takes command result as parameter.
    ///
    /// #Returns
    /// Encrypted document as byte array.
    ///
    /// #Errors
    /// No method specific errors.
    /// See `CryptoError` docs for common errors description.
    pub fn sodium_encrypt(public_key: &[&u8], doc: &[&u8], cb: Box<Fn(Result<Vec<u8>, CryptoError>) + Send>) {
        unimplemented!();
    }

    /// Decrypts encrypted document with Libsodium/ECC based asymmetric crypto algorithm.
    ///
    /// #Params
    /// private_key: Libsodium private key as byte array. Can be generated by calling `sodium_create_key_pair`.
    /// doc: Document to decrypt as byte array.
    /// cb: Callback that takes command result as parameter.
    ///
    /// #Returns
    /// Decrypted document as byte array.
    ///
    /// #Errors
    /// No method specific errors.
    /// See `CryptoError` docs for common errors description.
    pub fn sodium_decrypt(private_key: &[&u8], doc: &[&u8], cb: Box<Fn(Result<Vec<u8>, CryptoError>) + Send>) {
        unimplemented!();
    }

    /// Signs document with Libsodium/ECC based asymmetric crypto algorithm.
    ///
    /// #Params
    /// private_key: Libsodium private key as byte array. Can be generated by calling `sodium_create_key_pair`.
    /// doc: Document to sign as byte array.
    /// cb: Callback that takes command result as parameter.
    ///
    /// #Returns
    /// Signed document as byte array.
    ///
    /// #Errors
    /// No method specific errors.
    /// See `CryptoError` docs for common errors description.
    pub fn sodium_sign(private_key: &[&u8], doc: &[&u8], cb: Box<Fn(Result<Vec<u8>, CryptoError>) + Send>) {
        unimplemented!();
    }

    /// Encrypts document with Libsodium/ECC based asymmetric crypto algorithm.
    ///
    /// #Params
    /// public_key: Libsodium public key as byte array. Can be generated by calling `sodium_create_key_pair`.
    /// doc: Document to encrypt as byte array.
    /// cb: Callback that takes command result as parameter.
    ///
    /// #Returns
    /// Encrypted document as byte array.
    ///
    /// #Errors
    /// No method specific errors.
    /// See `CryptoError` docs for common errors description.
    pub fn sodium_verify(public_key: &[&u8], doc: &[&u8], cb: Box<Fn(Result<Vec<u8>, CryptoError>) + Send>) {
        unimplemented!();
    }

    /// Encodes source byte array as base58 string.
    ///
    /// #Params
    /// src: Byte array to encode.
    /// cb: Callback that takes command result as parameter.
    ///
    /// #Returns
    /// Encoded source as base58 string.
    ///
    /// #Errors
    /// No method specific errors.
    /// See `CryptoError` docs for common errors description.
    pub fn base58_encode(src: &[&u8], cb: Box<Fn(Result<String, CryptoError>) + Send>) {
        unimplemented!();
    }

    /// Decodes base58 string to source byte array.
    ///
    /// #Params
    /// str: Base58 string to decode.
    /// cb: Callback that takes command result as parameter.
    ///
    /// #Returns
    /// Source byte array.
    ///
    /// #Errors
    /// No method specific errors.
    /// See `CryptoError` docs for common errors description.
    pub fn base58_decode(str: &str, cb: Box<Fn(Result<Vec<u8>, CryptoError>) + Send>) {
        unimplemented!();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn crypto_api_can_be_created() {
        let crypto_api = CryptoAPI::new(Arc::new(CommandExecutor::new()));
        assert! (true, "No crashes on WalletAPI::new");
    }

    #[test]
    fn crypto_api_can_be_dropped() {
        fn drop_test() {
            let crypto_api = CryptoAPI::new(Arc::new(CommandExecutor::new()));
        }

        drop_test();
        assert! (true, "No crashes on WalletAPI::drop");
    }
}