using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using static Indy.Sdk.Dotnet.LibSovrin;

namespace Indy.Sdk.Dotnet.Wrapper
{
    /// <summary>
    /// Base class for all asynchronous wrapper classes.
    /// </summary>
    public abstract class AsyncWrapperBase
    {
        /// <summary>
        /// The next command handle to use.
        /// </summary>
        private static IntPtr _nextCommandHandle = IntPtr.Zero;

        /// <summary>
        /// Gets the map of command handles and their task completion sources.
        /// </summary>
        protected static Dictionary<IntPtr, object> TaskCompletionSources { get; }

        /// <summary>
        /// Gets the callback to use for functions that don't return a value.
        /// </summary>
        protected static ResultOnlyDelegate ResultOnlyCallback { get; }

        /// <summary>
        /// Static constructor.
        /// </summary>
        static AsyncWrapperBase()
        {
            TaskCompletionSources = new Dictionary<IntPtr, object>();

            ResultOnlyCallback = (xCommandHandle, err) =>
            {
                var taskCompletionSource = GetTaskCompletionSourceForCommand<bool>(xCommandHandle);

                if (!CheckCallback(taskCompletionSource, xCommandHandle, err))
                    return;

                taskCompletionSource.SetResult(true);
            };
        }
        
        /// <summary>
        /// Creates and stores a TaskCompletionSource for the specified command.
        /// </summary>
        /// <typeparam name="T">The type of data the Task generated by the TaskCompletionSource will return.</typeparam>
        /// <param name="commandHandle">The handle of the command the TaskCompletionSource should be associated with.</param>
        /// <returns>The new TaskCompletionSource.</returns>
        protected static TaskCompletionSource<T> CreateTaskCompletionSourceForCommand<T>(IntPtr commandHandle)
        {
            var taskCompletionSource = new TaskCompletionSource<T>();
            TaskCompletionSources.Add(commandHandle, taskCompletionSource);
            return taskCompletionSource;
        }

        /// <summary>
        /// Checks the result from a Sovrin function call.
        /// </summary>
        /// <exception cref="SovrinException">If the result is not a success result a SovrinException will be thrown.</exception>
        /// <param name="result">The result to check.</param>
        protected static void CheckResult(int result)
        {
            if (result != (int)ErrorCode.Success)
                throw SovrinException.fromErrorCode(result);
        }

        /// <summary>
        /// Checks the result of a callback made by the Sovrin library.
        /// </summary>
        /// <typeparam name="T">The type the promise will return.</typeparam>
        /// <param name="taskCompletionSource">The source controlling the async result.</param>
        /// <param name="xCommandHandle">The command handle of the command that was processed.</param>
        /// <param name="errorCode">The error code returned to the callback by the sovrin function.</param>
        /// <returns>true if the error code was success, otherwise false.</returns>
        /// <exception cref="SovrinException">If the errorCode is not a success result a SovrinException will be thrown.</exception>
        protected static bool CheckCallback<T>(TaskCompletionSource<T> taskCompletionSource, IntPtr xCommandHandle, int errorCode)
        {
            if (errorCode != (int)ErrorCode.Success)
            {
                taskCompletionSource.SetException(SovrinException.fromErrorCode(errorCode));
                return false;
            }

            return true;
        }

        /// <summary>
        /// Gets the next command handle.
        /// </summary>
        /// <returns>The next command handle.</returns>
        protected static IntPtr GetNextCommandHandle()
        {
            _nextCommandHandle = IntPtr.Add(_nextCommandHandle, 1);
            return _nextCommandHandle;
        }

        /// <summary>
        /// Gets the TaskCompletionSource associated with the specified command.
        /// </summary>
        /// <typeparam name="T">The type of the TaskCompletionSource.-</typeparam>
        /// <param name="commandHandle">The handle of the command.</param>
        /// <returns>The TaskCompletionSource associated with the command.</returns>
        public static TaskCompletionSource<T> GetTaskCompletionSourceForCommand<T>(IntPtr commandHandle)
        {
            if (!TaskCompletionSources.ContainsKey(commandHandle))
                throw new ApplicationException(string.Format("No task completion source is currently registered for the command with the handle '{0}'.", commandHandle));

            var taskCompletionSource = TaskCompletionSources[commandHandle];
            TaskCompletionSources.Remove(commandHandle);

            if (taskCompletionSource == null)
                throw new ApplicationException(string.Format("No  task completion source is registered for the command with the handle '{0}'.", commandHandle));

            var result = taskCompletionSource as TaskCompletionSource<T>;

            if (result == null)
                throw new ApplicationException(string.Format("The  task completion source registered for the command with the handle '{0}' does not match the type specified.", commandHandle));  

            return result;
        }
    }
}
